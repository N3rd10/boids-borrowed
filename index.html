<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CS 418 Boids</title>
    <script src="math.js"></script><!-- Basic math operations -->
    <script src="matrices.js"></script><!-- Basic matrix operations -->
<script>
const IlliniBlue = new Float32Array([0.075, 0.16, 0.292, 1])
const blackBackground = new Float32Array([0,0,0,1])
const g = 9.80665 
const eulerUpdatePosition = (p, v, t) => p.map((e, i) => e + v[i] * t)
const eulerUpdateVelocity = (v, a, t) => v.map((e, i) => e + a[i] * t)
const numBoids = 100
const boidSpeed = 2
const maxSpeed = 4
const minSpeed = 1.5
const aWeight = 2
const cWeight = 0.008
const sWeight = 0.08
const bvWeight = 0.008
const boundary = 0.9
const wall = 1
let startTime
let prevTime
let frameCount = 0

function computeBoidColor(boid, flockMates) {
    // Red: based on speed (velocity magnitude)
    let speed = mag(boid.velocity)
    let normalizedSpeed = (speed - minSpeed) / (maxSpeed - minSpeed)
    let r = clamp(normalizedSpeed, 0, 1)
    
    // Green: based on number of flockmates (sociability)
    let normalizedFlockSize = clamp(flockMates.length / (numBoids * 0.2), 0, 1)
    let g = normalizedFlockSize
    
    // Blue: based on distance from center
    let distanceFromCenter = mag(boid.position)
    let normalizedDistance = clamp(1 - (distanceFromCenter / wall), 0, 1)
    let b = normalizedDistance
    
    // Set alpha to 1
    return new Float32Array([r, g, b, 1])
}

/**
 * @param boid the input boid
 * Return an array of nearby boids
 */
function getFlockMates(boid) {
    let radius = boid.supportRadius
    let flockMates = []
    boids.forEach(b => {
        if (!Object.is(boid, b) && getDistance(boid, b) <= radius)
            flockMates.push(b)
    })
    return flockMates
}
/**
 * @param boid  input boid
 * @param v     velocity to steer towards
 * Steer v1 towards v2
 */
function steer(boid, v) {
    let steeringForce = sub(v, boid.velocity)
    let forceMagnitude = mag(steeringForce) 

    if (forceMagnitude > maxSpeed) 
        steeringForce = mul(normalize(steeringForce), maxSpeed)

    boid.velocity = add(boid.velocity, steeringForce)
}
/**
 * @param boid  input boid
 * apply a velocity towards the center of the screen
 */
function getBoundingVelocity(boid) {
    let d = sub([0,0,0], boid.position)
    let v = mul(normalize(d), mag(d))
    return v
}

/**
 * @param boid   input boid
 * @param v      input velocity
 * apply a dampening force to boids near the border
 */
function dampenVelocity(boid, v) {
  let ve = [...v]
  let dampingFactor = 1
  let distanceToBoundary = boundary - Math.abs(boid.position[0])

  if (distanceToBoundary <= 0.5) {
    dampingFactor = 0.5 + 0.5 * (distanceToBoundary / 0.5)
  }

  if (boid.position[0] < -boundary) {
    ve[0] += dampingFactor
  } else if (boid.position[0] > boundary) {
    ve[0] -= dampingFactor
  }

  distanceToBoundary = boundary - Math.abs(boid.position[1])

  if (distanceToBoundary <= 0.5) {
    dampingFactor = 0.5 + 0.5 * (distanceToBoundary / 0.5)
  }

  if (boid.position[1] < -boundary) {
    ve[1] += dampingFactor
  } else if (boid.position[1] > boundary) {
    ve[1] -= dampingFactor
  }

  return ve
}

/**
 * @param boid          input boid
 * @param repelForce    the magnitude of the reverse velocity to apply
 * If a boid reaches the wall, repel it in the opposite direction
 */
function repelFromWalls(boid, repelForce) {
    let repelVelocity = [0, 0, 0]

    if (boid.position[0] <= -1 * wall || boid.position[0] >= wall) {
        repelVelocity[0] = boid.position[0] <= 0 ? repelForce : -repelForce
    }

    if (boid.position[1] <= -1 * wall || boid.position[1] >= wall) {
        repelVelocity[1] = boid.position[1] <= 0 ? repelForce : -repelForce
    }

    return repelVelocity
}

/**
 * @param flockMates    array of flockMates
 * @param boid          input boid
 * Compute cohesion between flockmates
 */
function computeCohesion(flockMates, boid) {
    let avgPosition = [0,0,0]
    flockMates.forEach(b => { 
        avgPosition = add(avgPosition, b.position)
    })
    avgPosition = div(avgPosition, flockMates.length)
    let v = sub(avgPosition, boid.position)
    return v
}
/**
 * @param flockMates    array of flockMates
 * @param boid          input boid
 * Compute separation between flockmates based on inverse distance weighting
 */
function computeSeparation(flockMates, boid) {
    let weightedPositions = [0, 0, 0];
    let wSum = 0;

    for (let i = 0; i < flockMates.length; i++) {
        let d = getDistance(boid, flockMates[i])
        let w = 1 / d;
        wSum += w;
        weightedPositions = add(weightedPositions, mul(flockMates[i].position, w))
    }

    if (flockMates.length === 1) {
        wSum = 1 / getDistance(boid, flockMates[0])
        weightedPositions = mul(boid.position, wSum)
    }

    let d = div(weightedPositions, wSum)
    let speed = mag(boid.velocity)
    let desiredHeading = Math.atan2(boid.position[1] - d[1], boid.position[0] - d[0])
    let desiredVelocity = [speed * Math.cos(desiredHeading), speed * Math.sin(desiredHeading), 0]

    return desiredVelocity
}

/**
 * @param flockMates    array of flockMates
 * @param boid          input boid
 * compute the alignment between flockmates
 */
function computeAlignment(flockMates, boid) {
    let avgVelocity = [0,0, 0]
    flockMates.forEach(b => { 
        avgVelocity = add(avgVelocity, b.velocity)
    })
    avgVelocity = div(avgVelocity, flockMates.length)
    return avgVelocity
}

function createBoid(x, y, vx, vy) {
    let boid = {
        position: [x, y, 0],
        velocity: [vx, vy, 0],
        color: new Float32Array([0.5, 0.5, 0.5, 1]), // Initial neutral color
        supportRadius: 0.05,
    }
    boid.acceleration = [0,0,0]
    return boid
}

let boids = []
for (let i = 0; i < numBoids; i++) {
    boids.push(createBoid(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1))
}

function draw(gl, program) {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
    gl.uniform4fv(gl.getUniformLocation(program, 'color'), blackBackground)

    for (let i = 0; i < boids.length; i++) {
        let boid = boids[i]
        let flockMates = getFlockMates(boid)

        let cohesion = computeCohesion(flockMates, boid)
        let separation = computeSeparation(flockMates, boid)
        let alignment = computeAlignment(flockMates, boid)

        let boundingVelocity = getBoundingVelocity(boid)
        let repelVelocity = repelFromWalls(boid, 0.1)

        let acceleration = [
            cohesion[0] * cWeight + separation[0] * sWeight + alignment[0] * aWeight + boundingVelocity[0] * bvWeight + repelVelocity[0],
            cohesion[1] * cWeight + separation[1] * sWeight + alignment[1] * aWeight + boundingVelocity[1] * bvWeight + repelVelocity[1],
            0
        ]

        boid.acceleration = acceleration
        boid.velocity = eulerUpdateVelocity(boid.velocity, acceleration, 0.1)
        boid.position = eulerUpdatePosition(boid.position, boid.velocity, 0.1)

        let newColor = computeBoidColor(boid, flockMates)
        boid.color = newColor
        gl.uniform4fv(gl.getUniformLocation(program, 'color'), newColor)

        // Draw the boid
        gl.drawArrays(gl.POINTS, 0, 1)
    }
}

function main() {
    let canvas = document.getElementById('canvas')
    let gl = canvas.getContext('webgl')

    if (!gl) {
        alert('WebGL not supported')
        return
    }

    gl.clearColor(0, 0, 0, 1)
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

    let program = createProgram(gl, vertexShader, fragmentShader)
    gl.useProgram(program)

    let vertexBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.01, -0.01, 0]), gl.STATIC_DRAW)

    let positionLocation = gl.getAttribLocation(program, 'position')
    gl.enableVertexAttribArray(positionLocation)
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0)

    startTime = performance.now()
    prevTime = startTime

    function animate() {
        let currentTime = performance.now()
        let deltaTime = (currentTime - prevTime) / 1000
        prevTime = currentTime

        draw(gl, program)

        frameCount++
        requestAnimationFrame(animate)
    }

    animate()
}

main()

</script>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
</body>
</html>
